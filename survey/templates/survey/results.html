{% extends "survey/base.html" %}
{% load anime_util %}
{% load util %}

{% block head %}
<style>
    .table-duo {
        font-size: 85%;
    }

    .table-title, .table-description {
        /* background-color: lightblue; */
        text-align: center;
    }
    .table-container {
        /* background-color: aliceblue; */
        z-index: -100;
    }

    .table-col-rank {
        width: 5%!important;
    }
    .table-col-image {
        width: 15%!important;
    }
    .table-col-name {
        width: auto!important;
        position: relative!important;
        z-index: 10;
    }
    .table-col-main {
        width: 10%!important;
        position: relative!important;
        text-align: right!important;
    }
    .table-col-extra {
        width: 7%!important;
        position: relative!important;
        text-align: right!important;
    }
    .table-row-progress-bar {
        position: absolute;
        top: 10%;
        height: 80%;
        z-index: -10;
        /*border-radius:.25rem;*/
        background-color: rgb(199, 230, 250);
    }
    td {
        vertical-align: middle!important;
    }
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@0.7.0"></script>
<script>
    function genericNumberFormatter(value, validFormatter) {
        switch (isNaN(value) || value) {
            case true:
                return typeof(value) === "number" ? "N/A" : value;
            case Infinity:
                return "\u221e";
            default:
                return validFormatter(value);
        }
    }

    function percentageFormatter(value) {
        return genericNumberFormatter(value, function (v) { return parseFloat(v).toFixed(1) + "%" });
    }
    function genderRatioFormatter(value) {
        return genericNumberFormatter(value, function(v) {
            if (v >= 1.0) {
                return parseFloat(v).toFixed(2) + " M:F";
            }
            else {
                return parseFloat(1.0/v).toFixed(2) + " F:M";
            }
        });
    }
    function scoreFormatter(value) {
        return genericNumberFormatter(value, function(v) { return parseFloat(v).toFixed(2) });
    }
    function genderScoreDiffFormatter(value) {
        return genericNumberFormatter(value, function (v) {
            if (v >= 0.0) {
                return parseFloat(v).toFixed(2) + " M";
            }
            else {
                return parseFloat(-v).toFixed(2) + " F";
            }
        });
    }
    function ageFormatter(value) {
        return genericNumberFormatter(value, function(v) { return parseFloat(v).toFixed(2) });
    }


    const animeInfo = {{ anime_info_json|safe }};
    const animeSeriesData = {{ anime_series_data_json|safe }};
    const specialAnimeData = {{ special_anime_data_json|safe }};
    const surveyIsPreseason = {{ survey.is_preseason|lower }};

    const columnTypes = {
        rank: {
            key: "rank",
            label: "",
            thClass: "table-col-rank",
            tdClass: "table-col-rank",
        },
        image: {
            key: "image",
            label: "",
            thClass: "table-col-image",
            tdClass: "table-col-image",
        },
        name: {
            key: "name",
            label: "Anime",
            thClass: "table-col-name",
            tdClass: "table-col-name",
        },
        popularity: {
            key: "popularity",
            label: "Pop.",
            formatter: percentageFormatter,
        },
        gender_popularity_ratio: {
            key: "gender_popularity_ratio",
            label: "Gender Ratio",
            formatter: genderRatioFormatter,
        },
        age: {
            key: "age",
            label: "Avg. Age",
            formatter: ageFormatter,
        },
        underwatched: {
            key: "underwatched",
            label: "Under-watched",
            formatter: percentageFormatter,
        },
        score: {
            key: "score",
            label: "Score",
            formatter: scoreFormatter,
        },
        gender_score_difference: {
            key: "gender_score_difference",
            label: "Score Diff.",
            formatter: genderScoreDiffFormatter,
        },
        surprise: {
            key: "surprise",
            label: "Sur-prise",
            formatter: percentageFormatter,
        },
        disappointment: {
            key: "disappointment",
            label: "Disa-ppoint-ment",
            formatter: percentageFormatter,
        }
    };

    for (let column_idx in columnTypes) {
        let column = columnTypes[column_idx];
        column["sortable"] = true;
        //column["thStyle"] = column["key"] == "name" ? "min-width:300px;width:300px;" : "min-width:70px;width:70px;";
    }

    function getTableItems(animeData) {
        const tableItems = [];
        for (const anime_id in animeData) {
            const item = Object.assign({}, animeData[anime_id]);
            item["name"] = animeInfo[anime_id];
            tableItems.push(item);
        }
        return tableItems;
    }

    function sortCompare(aRow, bRow, key, sortDesc, formatter, compareOptions, compareLocale) {
        const a = aRow[key];
        const b = bRow[key];

        if (key == "name") {
            // Sort names by the first official name (should be the Japanese name).
            const aName = a["official_name_list"][0];
            const bName = b["official_name_list"][0];
            return aName < bName ? -1 : aName > bName ? 1 : 0;
        }
        else if (typeof(a) == "number" && typeof(b) == "number") {
            // Treat NaN as the lowest number possible.
            if (isNaN(a)) return -1;
            if (isNaN(b)) return 1;
            return a < b ? -1 : a > b ? 1 : 0;
        }
        else {
            return null;
        }
    }

    function setColumnCssClass(column, cssClass) {
        const result = Object.assign({}, column);
        result["tdClass"] = cssClass;
        result["thClass"] = cssClass;
        return result;
    }

    function processData(tableItems, sortKey, sortDesc, topCount, bottomCount) {
        // Sort.
        tableItems.sort(function(a, b) {
            const comparison = sortCompare(a, b, sortKey);
            return (sortDesc ? -1.0 : 1.0) * (comparison ? comparison : a[sortKey] - b[sortKey]);
        });

        // Filter anime below popularity threshold.
        tableItems = tableItems.filter(function(item) { return item["popularity"] > 2.0});

        // Calculate the min and max values for the progress bar value.
        let pbMin = 0.0;
        let pbMax = 85.0;
        let pbValueConversion = function(value) { return value };
        switch (sortKey) {
            case "score":
                pbMin = 1.0;
                pbMax = 5.0;
                break;
            case "gender_score_difference":
            case "gender_score_difference_inv":
                pbMax = 1.5;
                pbValueConversion = function(value) { return Math.abs(value) };
                break;
            case "gender_popularity_ratio":
            case "gender_popularity_ratio_inv":
                pbMax = 10.0;
                pbValueConversion = function(value) { return value >= 1.0 ? value : 1.0 / value };
                break;
            case "age":
                pbMin = 20.0;
                pbMax = 30.0;
                break;
        }

        // Add progress bar value and item rank.
        for (let i = 0; i < tableItems.length; i++) {
            let pbValue = pbValueConversion(tableItems[i][sortKey]);
            pbValue = (pbValue - pbMin) / (pbMax - pbMin);
            pbValue = Math.min(Math.max(pbValue, 0.0), 1.0);
            tableItems[i]["pb_width"] = "width:" + String(pbValue * 100.0) + "%;";
            tableItems[i]["rank"] = i + 1;
        }

        // Slice table to only include top X and bottom Y.
        if (typeof(topCount) === "number") {
            if (typeof(bottomCount) === "number") {
                const filler = {
                    name: {
                        official_name_list: ["..."],
                        image: null,
                    },
                }
                filler[sortKey] = "...";
                return tableItems.slice(0, topCount).concat([filler], tableItems.slice(-bottomCount));
            }
            return tableItems.slice(0, topCount);
        }
        return tableItems;
    }
</script>
{% endblock %}

{% block content %}

<h1 class="mb-3">{{ survey }} Results!</h1>

<div class="row">
    <div class="col-md-8">
        <div class="row"><div class="col">
            Thanks everyone for filling in this survey! There were {{ response_count }} responses,
            and the average age of everyone who answered was {{ average_age|floatformat:2 }}.
        </div></div>
        <div class="row mt-2"><div class="col">
            <canvas id="age-distribution-chart"></canvas>
        </div></div>
    </div>
    <div class="col-md-4">
        <canvas id="gender-distribution-chart"></canvas>
    </div>
</div>


{% include 'survey/results_segment.html' with depth=2 item=root_item only%}


<div class="row justify-content-between mt-3">
    <div class="col-auto">
        <a href="{% url 'survey:index' %}" class="btn btn-secondary">Back to index</a>
    </div>
    <div class="col-auto">
        <a href="{% url 'survey:fullresults' survey.year survey.season survey.is_preseason|yesno:'pre,post' %}" class="btn btn-primary">View full results</a>
    </div>
</div>


<script>
    var distributionChartColor = 'rgb(54, 162, 235)';
    var distributionChartDatalabelColor = 'rgb(96, 96, 96)';

    var gdcCtx = document.getElementById('gender-distribution-chart').getContext('2d');
    var gdcChart = new Chart(gdcCtx, {
        type: 'bar',
        data: {
            labels: [{% for gender in gender_distribution.keys %}'{{ gender.name.lower|capfirst }}', {% endfor %}],
            datasets: [{
                label: 'Percentage of responders',
                backgroundColor: distributionChartColor,
                borderColor: distributionChartColor,
                data: [{% for value in gender_distribution.values %}{{ value|floatformat:1 }}, {% endfor %}],
            }],
        },
        options: {
            title: {
                display: true,
                text: 'Gender Distribution',
            },
            tooltips: {
                callbacks: {
                    label: function(tooltipItem, data) {
                        var label = data.datasets[tooltipItem.datasetIndex].label || '';

                        if (label) {
                            label += ': ' + tooltipItem.yLabel + '%';
                        }
                        return label;
                    },
                },
            },
            legend: {
                display: false,
            },
            plugins: {
                datalabels: {
                    align: 'top',
                    anchor: 'end',
                    color: distributionChartDatalabelColor,
                    offset: -2,
                    formatter: function(value) {
                        return value + '%';
                    },
                }
            },
            scales: {
                yAxes: [{
                    ticks: {
                        callback: function(value) {
                            return value + '%';
                        },
                        min: 0,
                        max: 100,
                    },
                }]
            },
        },
    });

    var adcCtx = document.getElementById('age-distribution-chart').getContext('2d');
    var adcChart = new Chart(adcCtx, {
        type: 'bar',
        data: {
            labels: [{% for age in age_distribution.keys %}{{ age }}, {% endfor %}],
            datasets: [{
                label: 'Percentage of responders',
                backgroundColor: distributionChartColor,
                borderColor: distributionChartColor,
                data: [{% for value in age_distribution.values %}{{ value|floatformat:2 }}, {% endfor %}],
            }],
        },
        options: {
            title: {
                display: true,
                text: 'Age Distribution',
            },
            tooltips: {
                callbacks: {
                    label: function(tooltipItem, data) {
                        var label = data.datasets[tooltipItem.datasetIndex].label || '';

                        if (label) {
                            label += ': ' + tooltipItem.yLabel + '%';
                        }
                        return label;
                    },
                },
            },
            legend: {
                display: false,
            },
            plugins: {
                datalabels: {
                    align: 'top',
                    anchor: 'end',
                    color: distributionChartDatalabelColor,
                    offset: -2,
                    formatter: function(value, context) {
                        if (context.dataIndex % 2 == 0 && value > 0.1) {
                            return value + '%';
                        }
                        else {
                            return '';
                        }
                    },
                }
            },
            scales: {
                yAxes: [{
                    ticks: {
                        callback: function(value) {
                            return value + '%';
                        },
                        min: 0,
                        max: Math.round({{ age_distribution_max }} * 1.1 + 0.5),
                    },
                }]
            },
        },
    });
</script>
{% endblock content %}